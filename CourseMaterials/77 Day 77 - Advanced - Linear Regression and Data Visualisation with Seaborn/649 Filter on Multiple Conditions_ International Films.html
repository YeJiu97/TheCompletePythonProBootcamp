<html><head><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/components/image.min.css"></head><body><div class="container"><div class="row"><div class="col-md-10 col-md-offset-1 ui image"><p class="lead"><p>So far, we've created subsets for our DataFrames based on a single condition. But what if we want to select our data based on more than one condition?&nbsp;For example, which films made money internationally (i.e., <code>data.USD_Worldwide_Gross != 0</code>), but had zero box office revenue in the United States (i.e., <code>data.USD_Domestic_Gross == 0</code>)?&nbsp;</p><p>How would we create a filter for these two conditions?&nbsp;One approach is to use the <code>.loc[] </code>property combined with the <a href="https://docs.python.org/3.4/library/operator.html#mapping-operators-to-functions" rel="noopener noreferrer" target="_blank">bitwise and</a> <code>&amp;</code> operator. </p><pre class="prettyprint linenums">international_releases = data.loc[(data.USD_Domestic_Gross == 0) &amp; <br>                                  (data.USD_Worldwide_Gross != 0)]</pre><p>Why does this work?&nbsp;Pandas is built on top of NumPy, which uses Python's bitwise operators. And these bitwise operators allow us to do comparisons on an element by element basis in both NumPy and Pandas! Here's an example: </p><figure><img height="156" src="https://img-c.udemycdn.com/redactor/raw/2020-10-14_18-25-38-1acab27e5b6c677db5828de681d34cbe.png" width="590"></figure><p>However, we're also checking if the domestic revenue was zero and the worldwide revenue was not zero. Because the bitwise operator takes precedence, we need to include parentheses <code>()</code>&nbsp;around the comparisons we'd like to prioritise. </p><figure><img src="https://img-c.udemycdn.com/redactor/raw/2020-10-14_18-30-07-f144e3467424b4262de238f33db8917e.png"></figure><p>However, this is not the only technique we can use to make multiple comparisons. </p><p><br></p><h4>Challenge</h4><p>Use the Pandas <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.query.html" rel="noopener noreferrer" target="_blank"><code>.query()</code> function</a> to accomplish the same thing. Create a subset for international releases that had some worldwide gross revenue, but made zero revenue in the United States.</p><p>Hint: This time you'll have to use the <code>and</code> keyword.</p><p><br></p><p>.</p><p>.</p><p>..</p><p>...</p><p>..</p><p>.</p><p>.</p><p><br></p><p><strong>Solution:&nbsp;Using the .query()&nbsp;function to filter on multiple conditions</strong></p><p>In this case, we enclose the entire query inside a string. </p><pre class="prettyprint linenums">international_releases = data.query('USD_Domestic_Gross == 0 and USD_Worldwide_Gross != 0')<br>print(f'Number of international releases: {len(international_releases)}')<br>international_releases.tail()</pre><p>The column names are recognised and we see the following:</p><figure><img src="https://img-c.udemycdn.com/redactor/raw/2020-10-14_18-34-38-3cdecd04820328d2020a3300f5bab57c.png"></figure><p><br></p><h4>Unreleased Films</h4><p>Now we can turn our attention to films in the dataset that were not released at the time the data was collected. This is why films like Singularity and Aquaman had zero revenue. </p><p><br></p><h4>Challenge</h4><ul><li><p>Identify which films were not released yet as of the time of data collection (May 1st, 2018).</p></li><li><p>How many films are included in the dataset that have not yet had a chance to be screened in the box office?&nbsp;</p></li><li><p>Create another DataFrame called <code>data_clean</code> that does not include these films. </p></li></ul><p><br></p><p><br></p><p>.</p><p>.</p><p>..</p><p>...</p><p>..</p><p>.</p><p>.</p><p><br></p><p><strong>Solution:&nbsp;Removing the unreleased films</strong></p><p>There are a total of 7 unreleased films at the time of data collection included in the dataset. </p><figure><img src="https://img-c.udemycdn.com/redactor/raw/2020-10-14_18-46-19-04127ebc60d12d2a5eb14800bbfd7a7a.png"></figure><p>From this point on, we'll work with another DataFrame called data_clean that does not include these films. </p><pre class="prettyprint linenums">data_clean = data.drop(future_releases.index)</pre><p><br></p><h4>Bonus Challenge:&nbsp;Films that Lost Money</h4><p>Having removed the unreleased films entirely can you calculate the percentage of films that did not break even at the box office?&nbsp;We already saw that more than the bottom quartile of movies appears to lose money when we ran <code>.describe()</code>. However, what is the true percentage of films where the costs exceed the worldwide gross revenue?&nbsp;</p><p><br></p><p>.</p><p>.</p><p>..</p><p>...</p><p>..</p><p>.</p><p>.</p><p><br></p><p><strong>Solution:&nbsp;Budget greater than revenue</strong></p><p>Again, there are different ways you could have calculated this. For example, using the <code>.loc[]</code> property, </p><pre class="prettyprint linenums">money_losing = data_clean.loc[data_clean.USD_Production_Budget &gt; data_clean.USD_Worldwide_Gross]<br>len(money_losing)/len(data_clean)</pre><p>or the <code>.query()</code> function</p><pre class="prettyprint linenums">money_losing = data_clean.query('USD_Production_Budget &gt; USD_Worldwide_Gross')<br>money_losing.shape[0]/data_clean.shape[0]</pre><p>In both cases, we see that a whopping 37.2% ðŸ˜® of films do not recoup their production budget at the box office. ðŸ’¸ðŸ’¸ðŸ’¸ Who knew that film finance could be so risky! ðŸ˜¬</p><p><br></p><p><br></p></p></div></div></div></body></html>